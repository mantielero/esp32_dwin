// https://es.scribd.com/document/762726909/DGUS-DWIN-T5UIC1
#include <Arduino.h>
#include <lvgl.h>
#include <HardwareSerial.h>

// ============= CONFIGURACIÓN =============
#define DWIN_RX 16
#define DWIN_TX 17
#define DWIN_WIDTH 272
#define DWIN_HEIGHT 480

// Configuración LVGL
#define LVGL_BUFFER_SIZE (DWIN_WIDTH * 40)  // Buffer de 40 líneas

// La dirección VP del Framebuffer en las pantallas DWIN T5L suele empezar aquí.
// Puede que necesites consultar la documentación de tu pantalla específica si no funciona.
#define DWIN_VP_FB 0x5000 

// ============= VARIABLES GLOBALES =============
HardwareSerial DWINSerial(2);

// Protocolo DWIN
const uint8_t FRAME_HEADER = 0xAA;
const uint8_t FRAME_TAIL[4] = {0xCC, 0x33, 0xC3, 0x3C};
const uint8_t CMD_HANDSHAKE = 0x00;
const uint8_t CMD_CLEAR_SCREEN = 0x01;
const uint8_t CMD_DRAW_POINT = 0x02;
const uint8_t CMD_SET_DIRECTION = 0x34;
const uint8_t CMD_UPDATE_LCD = 0x3D;

uint8_t sendBuf[512];
uint8_t bufIndex = 0;

// Buffers LVGL
static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf1[LVGL_BUFFER_SIZE];
static lv_disp_drv_t disp_drv;


// ============= FUNCIONES AUXILIARES DWIN =============
void startFrame() {
  bufIndex = 0;
  sendBuf[bufIndex++] = FRAME_HEADER;
}

void addByte(uint8_t value) {
  sendBuf[bufIndex++] = value;
}

void addWord(uint16_t value) {
  sendBuf[bufIndex++] = (value >> 8) & 0xFF;  // High byte
  sendBuf[bufIndex++] = value & 0xFF;         // Low byte
}

void addString(const char* str) {
  while (*str) {
    sendBuf[bufIndex++] = *str++;
  }
}

void sendFrame() {
  // Enviar buffer
  DWINSerial.write(sendBuf, bufIndex);
  // Enviar tail
  DWINSerial.write(FRAME_TAIL, 4);
  
  delay(1); // Pequeño delay entre comandos
  //delayMicroseconds(100); // Pequeña pausa
}

bool dwinHandshake() {
  startFrame();
  addByte(CMD_HANDSHAKE);
  sendFrame();
  
  delay(100);
  
  uint8_t response[26];
  int recNum = 0;
  unsigned long timeout = millis();
  
  while (millis() - timeout < 500 && recNum < 26) {
    if (DWINSerial.available()) {
      response[recNum] = DWINSerial.read();
      if (response[0] != 0xAA && recNum > 0) {
        recNum = 0;
        continue;
      }
      recNum++;
      delay(10);
    }
  }
  
  return (recNum >= 4 && response[0] == 0xAA && 
          response[1] == 0x00 && response[2] == 'O' && response[3] == 'K');
}

void dwinClearScreen(uint16_t color) {
  startFrame();
  addByte(CMD_CLEAR_SCREEN);
  addWord(color);
  sendFrame();
}

void dwinSetOrientation(uint8_t dir) {
  startFrame();
  addByte(CMD_SET_DIRECTION);
  addByte(0x5A);
  addByte(0xA5);
  addByte(dir);
  sendFrame();
}

void dwinUpdateLCD() {
  startFrame();
  addByte(CMD_UPDATE_LCD);
  sendFrame();
}

// ============= FUNCIÓN CRÍTICA: Dibujar múltiples píxeles =============
// Esta función dibuja varios píxeles de una vez usando el comando 0x02
/*
void dwinDrawPixels(uint16_t x, uint16_t y, uint16_t width, uint16_t height, 
                    const lv_color_t* color_array, uint32_t pixel_count) {
  // Limitar por seguridad
  if (pixel_count > 200) pixel_count = 200;
  
  startFrame();
  addByte(CMD_DRAW_POINT);  // Comando 0x02
  
  // Para cada pixel
  for (uint32_t i = 0; i < pixel_count; i++) {
    // Convertir color LVGL (RGB565) a formato DWIN
    uint16_t color = lv_color_to16(color_array[i]);
    
    addWord(color);      // Color del pixel
    addByte(1);          // Ancho del pixel (Nx)
    addByte(1);          // Alto del pixel (Ny)
    
    // Calcular posición del pixel
    uint16_t px = x + (i % width);
    uint16_t py = y + (i / width);
    
    addWord(px);         // Posición X
    addWord(py);         // Posición Y
    
    // Limitar tamaño del buffer
    if (bufIndex > 400) {
      sendFrame();
      startFrame();
      addByte(CMD_DRAW_POINT);
    }
  }
  
  sendFrame();
}
*/
// ============= CALLBACK FLUSH PARA LVGL =============
// ============= CALLBACK FLUSH PARA LVGL (VERSIÓN DEFINITIVA) =============
// Esta función envía el buffer de LVGL a la pantalla usando la lógica del script de Python
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
  uint32_t w = lv_area_get_width(area);
  uint32_t h = lv_area_get_height(area);

  // El script de Python envía la imagen completa. Aquí imitamos eso para el área de actualización.
  // No necesitamos chunking si el buffer 'sendBuf' es suficientemente grande,
  // pero lo mantenemos como buena práctica por si LVGL envía áreas muy grandes.
  // Para este ejemplo, enviaremos todo el área 'area' en una sola trama.
  // Asegúrate de que LVGL_BUFFER_SIZE no sea tan grande que 'w*h*2' desborde 'sendBuf'.

  startFrame();
  addByte(0x82); // Comando para escribir datos de imagen en coordenadas

  // Añadir las coordenadas de inicio (X, Y)
  addWord(area->x1);
  addWord(area->y1);

  // Añadir los datos de color (w * h * 2 bytes)
  // El script de Python confirma que el orden de bytes es Big-Endian
  for (uint32_t i = 0; i < w * h; i++) {
    uint16_t color = lv_color_to16(color_p[i]);
    addByte((color >> 8) & 0xFF); // Byte alto
    addByte(color & 0xFF);        // Byte bajo
  }
  
  sendFrame();

  // Informar a LVGL que hemos terminado
  lv_disp_flush_ready(disp);
}
// Esta es la función más importante: envía el buffer de LVGL a la pantalla
/*
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
  uint32_t w = (area->x2 - area->x1 + 1);
  uint32_t h = (area->y2 - area->y1 + 1);
  uint32_t total_pixels = w * h;
  
  // Dibujar en bloques pequeños para no saturar el buffer serial
  const uint32_t chunk_size = 50;  // Píxeles por envío
  
  for (uint32_t i = 0; i < total_pixels; i += chunk_size) {
    uint32_t pixels_to_send = min(chunk_size, total_pixels - i);
    uint16_t chunk_y = i / w;
    uint16_t chunk_x = i % w;
    
    dwinDrawPixels(area->x1 + chunk_x, area->y1 + chunk_y, 
                   w, h, &color_p[i], pixels_to_send);
  }
  
  // Informar a LVGL que hemos terminado
  lv_disp_flush_ready(disp);
}
*/


// Reemplaza tu función my_disp_flush con esta versión optimizada
/*
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
  uint32_t w = lv_area_get_width(area);
  uint32_t h = lv_area_get_height(area);
  uint32_t total_pixels = w * h;

  // El buffer de envío serial tiene un límite, enviamos en trozos (chunks)
  // Un tamaño de chunk seguro es ~240 píxeles (480 bytes de color + cabecera)
  const uint32_t chunk_size_pixels = 240; 
  uint32_t pixels_sent = 0;

  while (pixels_sent < total_pixels) {
    uint32_t pixels_to_send = total_pixels - pixels_sent;
    if (pixels_to_send > chunk_size_pixels) {
      pixels_to_send = chunk_size_pixels;
    }

    // Calcular la posición del chunk actual
    uint16_t current_y = area->y1 + (pixels_sent / w);
    uint16_t current_x = area->x1 + (pixels_sent % w);
    
    // Calcular la dirección de memoria (VP) para este chunk
    // La fórmula es VP_BASE + (Y * ANCHO_PANTALLA + X)
    uint32_t vp_addr = DWIN_VP_FB + ((uint32_t)current_y * DWIN_WIDTH + current_x);

    // Construir la trama DWIN
    startFrame();
    addByte(0x82); // Comando para escribir en una dirección VP
    addWord(vp_addr >> 8); // DWIN usa VP en palabras, por lo que dividimos por 2. Incorrecto, VP es la dirección directa. Lo corregimos.
                         // Corrección: el VP es una dirección de palabra (16-bit), así que la dirección de byte se usa directa.
    addWord((uint16_t)vp_addr);

    addByte(pixels_to_send * 2); // Longitud en BYTES (cada pixel son 2 bytes)

    // Añadir los datos de color, corrigiendo el orden de bytes (Endianness)
    for (uint32_t i = 0; i < pixels_to_send; i++) {
      // LVGL usa Little-Endian, DWIN espera Big-Endian. Hay que intercambiar los bytes.
      uint16_t color = lv_color_to16(color_p[pixels_sent + i]);
      addByte((color >> 8) & 0xFF); // Byte alto primero
      addByte(color & 0xFF);        // Byte bajo después
    }
    
    sendFrame();
    pixels_sent += pixels_to_send;
  }

  // Informar a LVGL que el buffer ha sido enviado y está listo para usarse de nuevo
  lv_disp_flush_ready(disp);
}
*/

// ============= CONFIGURACIÓN LVGL =============
void lvgl_setup() {
  // Inicializar LVGL
  lv_init();
  
  // Configurar buffer de dibujo
  lv_disp_draw_buf_init(&draw_buf, buf1, NULL, LVGL_BUFFER_SIZE);
  
  // Inicializar y registrar el driver de display
  lv_disp_drv_init(&disp_drv);
  disp_drv.hor_res = DWIN_WIDTH;
  disp_drv.ver_res = DWIN_HEIGHT;
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  lv_disp_drv_register(&disp_drv);
  
  Serial.println("✓ LVGL configurado");
}

// ============= SETUP Y LOOP =============
void setup() {
  Serial.begin(115200);
  DWINSerial.begin(115200, SERIAL_8N1, DWIN_RX, DWIN_TX);
  
  delay(500);
  
  Serial.println("\n=== Inicializando DWIN + LVGL ===");
  
  // Inicializar pantalla DWIN
  if (dwinHandshake()) {
    Serial.println("✓ Handshake DWIN exitoso");
    delay(100);
    
    dwinSetOrientation(1);
    delay(50);
    
    dwinClearScreen(0x0000);  // Negro
    delay(100);
    
    dwinUpdateLCD();
    
    // Inicializar LVGL
    lvgl_setup();
    
    // Crear UI de ejemplo
    createExampleUI();
    
  } else {
    Serial.println("✗ Error en handshake DWIN");
  }
}

void loop() {
  // Procesar tareas de LVGL
  lv_timer_handler();
  delay(5);
}

// ============= UI DE EJEMPLO =============
void createExampleUI() {
  // Crear una etiqueta
  lv_obj_t * label = lv_label_create(lv_scr_act());
  lv_label_set_text(label, "Hola mundo\ncon LVGL!");
  lv_obj_align(label, LV_ALIGN_CENTER, 0, -40);
  // Usar fuente por defecto (14) que siempre está disponible
  
  // Crear un botón
  lv_obj_t * btn = lv_btn_create(lv_scr_act());
  lv_obj_align(btn, LV_ALIGN_CENTER, 0, 40);
  lv_obj_add_event_cb(btn, btn_event_cb, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t * btn_label = lv_label_create(btn);
  lv_label_set_text(btn_label, "Click me!");
  lv_obj_center(btn_label);
  
  Serial.println("✓ UI creada");
}

// Callback del botón
void btn_event_cb(lv_event_t * e) {
  Serial.println("¡Botón presionado!");
  
  lv_obj_t * btn = lv_event_get_target(e);
  lv_obj_t * label = lv_obj_get_child(btn, 0);
  
  static bool pressed = false;
  pressed = !pressed;
  
  if (pressed) {
    lv_label_set_text(label, "Pressed!");
  } else {
    lv_label_set_text(label, "Click me!");
  }
}
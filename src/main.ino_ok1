#include <HardwareSerial.h>

// DWIN T5UIC1 Screen Configuration
HardwareSerial DWINSerial(2); // Use ESP32's UART2 for DWIN screen

// Connection Pins
#define DWIN_RX 16  // ESP32 GPIO16 -> DWIN TX
#define DWIN_TX 17  // ESP32 GPIO17 -> DWIN RX

// DWIN T5UIC1 Protocol (Ender 3 V2)
const uint8_t FRAME_HEADER = 0xAA;
const uint8_t FRAME_TAIL[4] = {0xCC, 0x33, 0xC3, 0x3C};


// Commands
const uint8_t CMD_HANDSHAKE = 0x00;
const uint8_t CMD_CLEAR_SCREEN = 0x01;
const uint8_t CMD_SET_POINT = 0x02;         // New: Set paint
const uint8_t CMD_DRAW_LINE = 0x03;         // New: End point connection
const uint8_t CMD_DRAW_RECT = 0x05;         // New: Rectangular area display
const uint8_t CMD_DRAW_BITMAP = 0x08;       // New: Two-color bitmap filling
const uint8_t CMD_MOVE_AREA = 0x09;         // New: Screen area move
const uint8_t CMD_DRAW_STRING = 0x11;
const uint8_t CMD_BACKLIGHT = 0x30;
const uint8_t CMD_SET_DIRECTION = 0x34;
const uint8_t CMD_UPDATE_LCD = 0x3D;        // Note: This command is not in the provided manual but is often used in DWIN.


// Font Sizes (from 0x11 command)
const uint8_t FONT_6x12 = 0x00;
const uint8_t FONT_8x16 = 0x01;
const uint8_t FONT_10x20 = 0x02;
const uint8_t FONT_12x24 = 0x03;
const uint8_t FONT_14x28 = 0x04;
const uint8_t FONT_16x32 = 0x05;
const uint8_t FONT_20x40 = 0x06;
const uint8_t FONT_24x48 = 0x07;
const uint8_t FONT_28x56 = 0x08;
const uint8_t FONT_32x64 = 0x09;

// Colors (RGB565)
const uint16_t COLOR_WHITE = 0xFFFF;
const uint16_t COLOR_BLACK = 0x0000;
const uint16_t COLOR_RED = 0xF800;
const uint16_t COLOR_GREEN = 0x07E0;
const uint16_t COLOR_BLUE = 0x001F;
const uint16_t COLOR_YELLOW = 0xFFE0;
const uint16_t COLOR_MAGENTA = 0xF81F;
const uint16_t COLOR_CYAN = 0x07FF;
const uint16_t COLOR_BG_BLACK = 0x0841;
const uint16_t COLOR_BG_BLUE = 0x1125;

// Screen Dimensions (Note: Dimensions seem swapped in your original code based on a 480x272 screen rotated 90 deg)
const uint16_t DWIN_WIDTH = 272;
const uint16_t DWIN_HEIGHT = 480;

// Buffer to build commands
uint8_t sendBuf[256];
uint8_t bufIndex = 0;
/*
void setup() {
  Serial.begin(115200);
  DWINSerial.begin(115200, SERIAL_8N1, DWIN_RX, DWIN_TX);
  
  delay(500);
  
  Serial.println("\n=== Inicializando pantalla DWIN T5UIC1 (Ender 3 V2) ===");
  
  // Realizar handshake
  if (handshake()) {
    Serial.println("✓ Handshake exitoso");
    
    delay(100);
    
    // Configurar orientación (1 = 90°, ajustar según tu montaje)
    setScreenOrientation(1);
    delay(50);
    
    // Limpiar pantalla
    clearScreen(COLOR_BG_BLACK);
    delay(100);
    
    // Escribir "Hola mundo"
    drawString(true, true, FONT_16x32, COLOR_WHITE, COLOR_BG_BLACK, 10, 100, "Hola mundo");
    
    // Actualizar pantalla
    updateLCD();
    
    Serial.println("✓ Texto mostrado en pantalla");
  } else {
    Serial.println("✗ Error en handshake");
  }
}

void loop() {
  // Ejemplo: cambiar el texto cada 3 segundos
  static unsigned long lastUpdate = 0;
  static bool toggle = false;
  
  if (millis() - lastUpdate > 3000) {
    lastUpdate = millis();
    toggle = !toggle;
    
    if (toggle) {
      drawString(true, true, FONT_16x32, COLOR_YELLOW, COLOR_BG_BLACK, 10, 100, "Hola mundo");
    } else {
      drawString(true, true, FONT_16x32, COLOR_GREEN, COLOR_BG_BLACK, 10, 100, "ESP32 DWIN");
    }
    updateLCD();
  }
}

*/

// ============= Funciones del protocolo DWIN T5UIC1 =============

void startFrame() {
  bufIndex = 0;
  sendBuf[bufIndex++] = FRAME_HEADER;
}

void addByte(uint8_t value) {
  sendBuf[bufIndex++] = value;
}

void addWord(uint16_t value) {
  sendBuf[bufIndex++] = (value >> 8) & 0xFF;  // High byte
  sendBuf[bufIndex++] = value & 0xFF;         // Low byte
}

void addString(const char* str) {
  while (*str) {
    sendBuf[bufIndex++] = *str++;
  }
}

void sendFrame() {
  // Send buffer
  DWINSerial.write(sendBuf, bufIndex);
  // Send tail
  DWINSerial.write(FRAME_TAIL, 4);
  
  delay(1); // Small delay between commands
}

// Handshake with the scree
bool handshake() {
  Serial.println("Enviando handshake...");
  
  startFrame();
  addByte(CMD_HANDSHAKE);
  sendFrame();
  
  delay(100);
  
  // Wait for response: AA 00 4F 4B (AA 00 'O' 'K')
  uint8_t response[26];
  int recNum = 0;
  unsigned long timeout = millis();
  
  while (millis() - timeout < 500 && recNum < 26) {
    if (DWINSerial.available()) {
      response[recNum] = DWINSerial.read();
      
      // Verificar que el primer byte es correcto
      if (response[0] != 0xAA && recNum > 0) {
        recNum = 0;
        continue;
      }
      
      recNum++;
      delay(10);
    }
  }
  
  // Verificar respuesta: AA 00 'O' 'K'
  bool success = (recNum >= 4 && 
                  response[0] == 0xAA && 
                  response[1] == 0x00 && 
                  response[2] == 'O' && 
                  response[3] == 'K');
  
  if (success) {
    Serial.printf("Respuesta handshake: ");
    for (int i = 0; i < min(recNum, 10); i++) {
      Serial.printf("%02X ", response[i]);
    }
    Serial.println();
  }
  
  return success;
}

/*  
  // Wait for response: AA 00 4F 4B (AA 00 'O' 'K')
  uint8_t response[6];
  DWINSerial.readBytes(response, 6); // Read fixed response
  
  // Check response: AA 00 'O' 'K' CC 33 C3 3C
  bool success = (response[0] == 0xAA && response[1] == 0x00 && response[2] == 0x4F && response[3] == 0x4B);
  
  if (success) {
    Serial.printf("Handshake response: %02X %02X %02X %02X...\n", response[0], response[1], response[2], response[3]);
  }
  
*/

// ================ Drawing Functions ================
// Clear screen
void clearScreen(uint16_t color) {
  startFrame();
  addByte(CMD_CLEAR_SCREEN);
  addWord(color);
  sendFrame();
  
  // DWIN Frame: AA 01 [Color H] [Color L] CC 33 C3 3C
  Serial.println("DWIN Frame: AA 01 [Color] CC 33 C3 3C");
}


// Set screen orientation
// dir: 0=0°, 1=90°, 2=180°, 3=270°
void setScreenOrientation(uint8_t dir) {
  startFrame();
  addByte(CMD_SET_DIRECTION);
  addByte(0x5A);
  addByte(0xA5);
  addByte(dir);
  sendFrame();

  // DWIN Frame: AA 34 5A A5 [Dir] CC 33 C3 3C
  Serial.println("DWIN Frame: AA 34 5A A5 [Dir] CC 33 C3 3C");
}


// Update LCD (refresh display memory)
void updateLCD() {
  // Note: This is an unlisted command (0x3D) often used for full screen refresh.
  // It is included based on common DWIN protocol knowledge, but verify if necessary for your application.
  // The provided manual does not list this command.
  // If not needed, you can remove it.
  startFrame();
  addByte(CMD_UPDATE_LCD); 
  sendFrame();
}


// Draw string
// widthAdjust: true=ajustar ancho automáticamente
// bShow: true=mostrar color de fondo
// size: tamaño de fuente (usar constantes FONT_*)
// color: color del texto (RGB565)
// bColor: color de fondo (RGB565)
// x, y: coordenadas superior izquierda
// text: texto a mostrar
void drawString(bool widthAdjust, bool bShow, uint8_t size, 
                uint16_t color, uint16_t bColor, 
                uint16_t x, uint16_t y, const char* text) {
  startFrame();
  addByte(CMD_DRAW_STRING);
  
  // Configuration Byte:
  // Bit 7: widthAdjust (1=adjust, 0=no adjust)
  // Bit 6: bShow (1=display background, 0=no display)
  // Bit 5-4: Reserved (Write 0)
  // Bit 3-0: size (Font size)
  uint8_t config = (widthAdjust ? 0x80 : 0x00) | 
                   (bShow ? 0x40 : 0x00) | 
                   (size & 0x0F);
  addByte(config);
  
  addWord(color);
  addWord(bColor);
  addWord(x);
  addWord(y);
  addString(text);
  
  sendFrame();
  // DWIN Frame: AA 11 [Mode] [Color] [Bcolor] [X] [Y] [Strings] CC 33 C3 3C
  Serial.println("DWIN Frame: AA 11 [Mode] [Color] [Bcolor] [X] [Y] [Strings] CC 33 C3 3C");

}



// Set backlight brightness (0x1F-0xFF)
void setBacklight(uint8_t brightness) {
  startFrame();
  addByte(CMD_BACKLIGHT);
  addByte(brightness < 0x1F ? 0x1F : brightness);
  sendFrame();
}






// Ejemplo de dibujar un número entero
void drawIntValue(bool bShow, bool zeroFill, bool zeroMode, uint8_t size,
                  uint16_t color, uint16_t bColor, uint8_t digits,
                  uint16_t x, uint16_t y, int32_t value) {
  startFrame();
  addByte(0x14); // Comando para dibujar número
  
  uint8_t config = (bShow ? 0x80 : 0x00) | 
                   (zeroFill ? 0x20 : 0x00) |
                   (zeroMode ? 0x10 : 0x00) |
                   (size & 0x0F);
  addByte(config);
  
  addWord(color);
  addWord(bColor);
  addByte(digits);  // Número de dígitos enteros
  addByte(0);       // Número de decimales
  addWord(x);
  addWord(y);
  
  // Enviar valor como 8 bytes (64 bits)
  for (int i = 7; i >= 0; i--) {
    addByte((value >> (i * 8)) & 0xFF);
  }
  
  sendFrame();
}



// ============= New Drawing related instructions =============

// Set point (CMD 0x02)
// Sets one or more points with custom pixel size (Nx, Ny)
void drawPoint(uint16_t color, uint8_t nx, uint8_t ny, const uint16_t* coords, size_t numPoints) {
  // DWIN Frame: AA 02 [Color] [Nx] [Ny] (X0 Y0)...(Xn Yn) CC 33 C3 3C
  startFrame();
  addByte(CMD_SET_POINT);
  addWord(color);
  addByte(nx); // Actual pixel size in X direction (0x01-0x0F)
  addByte(ny); // Actual pixel size in Y direction (0x01-0x0F)

  for (size_t i = 0; i < numPoints * 2; i++) { // coords array is [X0, Y0, X1, Y1, ...]
    addWord(coords[i]);
  }

  sendFrame();
  Serial.println("DWIN Frame: AA 02 [Color] [Nx] [Ny] (X0 Y0)... CC 33 C3 3C");
}

// Draw line (CMD 0x03)
// Connects a sequence of points
void drawLine(uint16_t color, const uint16_t* coords, size_t numPoints) {
  // DWIN Frame: AA 03 [Color] (X0 Y0)...(Xn Yn) CC 33 C3 3C
  startFrame();
  addByte(CMD_DRAW_LINE);
  addWord(color);

  for (size_t i = 0; i < numPoints * 2; i++) { // coords array is [X0, Y0, X1, Y1, ...]
    addWord(coords[i]);
  }

  sendFrame();
  Serial.println("DWIN Frame: AA 03 [Color] (X0 Y0)... CC 33 C3 3C");
}

// Draw rectangle (CMD 0x05)
// Displays a rectangular area (frame, fill, or XOR)
// Mode: 0x00=frame, 0x01=fill, 0x02=XOR fill
void drawRectangle(uint8_t mode, uint16_t color, 
                   uint16_t xs, uint16_t ys, uint16_t xe, uint16_t ye) {
  // DWIN Frame: AA 05 [Mode] [Color] [Xs] [Ys] [Xe] [Ye] CC 33 C3 3C
  startFrame();
  addByte(CMD_DRAW_RECT);
  addByte(mode);
  addWord(color);
  addWord(xs); // Upper left X
  addWord(ys); // Upper left Y
  addWord(xe); // Lower right X
  addWord(ye); // Lower right Y

  sendFrame();
  Serial.println("DWIN Frame: AA 05 [Mode] [Color] [Xs] [Ys] [Xe] [Ye] CC 33 C3 3C");
}

// Draw two-color bitmap (CMD 0x08)
// Draws a two-color bitmap using data bytes. Bit 1 is Color1, Bit 0 is Color0.
// Note: Bitmap data needs to be left-aligned to 1 Byte in the width direction.
void drawBitmap(uint16_t x, uint16_t y, uint16_t wide, 
                uint16_t color1, uint16_t color0, 
                const uint8_t* data, size_t dataLength) {
  // DWIN Frame: AA 08 [X] [Y] [Wide] [Color1] [Color0] [data] CC 33 C3 3C
  startFrame();
  addByte(CMD_DRAW_BITMAP);
  addWord(x);
  addWord(y);
  addWord(wide); // Width of the filled area
  addWord(color1); // Fill color for bit 1
  addWord(color0); // Fill color for bit 0

  for (size_t i = 0; i < dataLength; i++) {
    addByte(data[i]);
  }

  sendFrame();
  Serial.println("DWIN Frame: AA 08 [X] [Y] [Wide] [Color1] [Color0] [data] CC 33 C3 3C");
}

// Move screen area (CMD 0x09)
// Moves a rectangular area (circular or translation)
// Mode: Bit 7=1:Translation, Bit 7=0:Circular. Bit 3-0: Direction (0x00=Left, 0x01=Right, 0x02=Up, 0x03=Down)
void moveArea(uint8_t mode, uint16_t dist, uint16_t color, 
              uint16_t xs, uint16_t ys, uint16_t xe, uint16_t ye) {
  // DWIN Frame: AA 09 [Mode] [DIS] [Color] [Xs] [Ys] [Xe] [Ye] CC 33 C3 3C
  startFrame();
  addByte(CMD_MOVE_AREA);
  addByte(mode);
  addWord(dist); // Moving distance in pixels
  addWord(color); // Fill color (only for translation mode - Bit 7=1)
  addWord(xs); // Upper left X
  addWord(ys); // Upper left Y
  addWord(xe); // Lower right X
  addWord(ye); // Lower right Y

  sendFrame();
  Serial.println("DWIN Frame: AA 09 [Mode] [DIS] [Color] [Xs] [Ys] [Xe] [Ye] CC 33 C3 3C");
}


void setup() {
  Serial.begin(115200);
  DWINSerial.begin(115200, SERIAL_8N1, DWIN_RX, DWIN_TX);
  
  delay(500);
  
  Serial.println("\n=== Initializing DWIN T5UIC1 screen (Ender 3 V2) ===");
  
  // Handshake
  if (handshake()) {
    Serial.println("✓ Handshake successful");
    
    delay(100);
    
    // Set Orientation (1 = 90° rotation)
    setScreenOrientation(1);
    delay(50);
    
    // Clear screen
    clearScreen(COLOR_BLACK);
    delay(100);
    
    // === Drawing Examples ===

    // 1. Draw Rectangle (Frame) - CMD 0x05, Mode 0x00
    // Draw a White frame from (20, 20) to (100, 200)
    //drawString(true, true, FONT_16x32, COLOR_WHITE, COLOR_BLACK, 10, 10, "1. Rectangle Frame (0x05)");
    //drawRectangle(0x00, COLOR_WHITE, 20, 50, 100, 200);
    //delay(50);

    // 2. Draw Rectangle (Fill) - CMD 0x05, Mode 0x01
    // Draw a Filled Red rectangle from (120, 20) to (200, 200)
    //drawString(true, true, FONT_16x32, COLOR_RED, COLOR_BLACK, 110, 10, "2. Rectangle Fill (0x05)");
    //drawRectangle(0x01, COLOR_RED, 120, 50, 200, 200);
    //delay(50);

    // 3. Draw Points - CMD 0x02
    // Draw 3 points: (220, 50), (225, 70), (230, 90) with size 4x4
    //drawString(true, true, FONT_16x32, COLOR_GREEN, COLOR_BLACK, 220, 10, "3. Points (0x02)");
    //uint16_t points[] = {220, 50, 225, 70, 230, 90};
    //drawPoint(COLOR_GREEN, 0x04, 0x04, points, 3);
    //delay(50);

    // 4. Draw Line - CMD 0x03
    // Draw a Yellow line connecting 4 points
    //drawString(true, true, FONT_16x32, COLOR_YELLOW, COLOR_BLACK, 10, 220, "4. Line (0x03)");
    //uint16_t lineCoords[] = {10, 250, 80, 280, 100, 230, 200, 300};
    //drawLine(COLOR_YELLOW, lineCoords, 4);
    //delay(50);

    // 5. Draw Two-Color Bitmap - CMD 0x08 [NOT OK]
    // Simple bitmap (5 pixels wide, e.g., for a 'T')
    //drawString(true, true, FONT_16x32, COLOR_MAGENTA, COLOR_BLACK, 10, 10, "5. Bitmap (0x08)");
    // 5 pixels wide (left-aligned in 1 Byte), 5 rows high. 
    // Data: 0xF8 (11111000), 0x10 (00010000), 0x10, 0x10, 0x10
    uint8_t bitmapData[] = {0xF8, 0x10, 0x10, 0x10, 0x10};
    uint8_t exampleBitmapData[] = {0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C};
    //drawBitmap(10, 10, 5, COLOR_MAGENTA, COLOR_BG_BLUE, bitmapData, sizeof(bitmapData));
    drawBitmap(10, 10, 8, COLOR_MAGENTA, COLOR_BG_BLUE, exampleBitmapData, sizeof(exampleBitmapData));
    delay(50);

    const uint8_t manualBitmapData[32] = {
    // Patrón simple de damero de 16x16:
    0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55, 0xAA, 
    0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55, 0xAA,
    0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55, 0xAA,
    0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55, 0xAA
    };


    // 2. Llamada a la función con los parámetros del manual:
    // X=50, Y=30, Wide=16, Color1=Red, Color0=Black, Data=manualBitmapData
    drawBitmap(
        50,                               // x: Coordenada inicial X (50)
        30,                               // y: Coordenada inicial Y (30)
        16,                               // wide: Ancho del mapa de bits en píxeles (16)
        COLOR_RED,                        // color1: Color para Bit 1
        COLOR_BLUE,                      // color0: Color para Bit 0
        manualBitmapData,                 // data: La matriz de 32 bytes
        sizeof(manualBitmapData)          // dataLength: 32 bytes (16 filas * 2 bytes/fila)
    );
    delay(50);

    // Final Screen Update
    updateLCD();
    Serial.println("✓ Drawing examples displayed on screen");
    
    // Prepare a section for the movement example in loop
    //drawRectangle(0x01, COLOR_BLUE, 10, 320, 200, 450);
    //drawString(true, true, FONT_16x32, COLOR_WHITE, COLOR_BLUE, 20, 330, "Move Area");
    //updateLCD();
    
  } else {
    Serial.println("✗ Handshake Error");
  }
}

void loop() {
  // Example: Circularly move the blue rectangle area every second
  static unsigned long lastUpdate = 0;
  
  if (millis() - lastUpdate > 50) {
    lastUpdate = millis();
    
    // 6. Circular Screen Area Move (CMD 0x09)
    // Mode: Bit 7=0 (Circular), Bit 3-0=0x01 (Right) -> Mode = 0x01
    // Distance: 1 pixel
    // Area: (10, 320) to (200, 450)
    // The vacant area is automatically filled when mode is circular.
    //moveArea(0x01, 0x0001, 0x0000, 10, 320, 200, 450); // Move Right 1 pixel
    //updateLCD();
  }
}


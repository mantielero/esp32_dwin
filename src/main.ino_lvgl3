#include <HardwareSerial.h>
#include <lvgl.h>

// DWIN T5UIC1 Screen Configuration
HardwareSerial DWINSerial(2); // Use ESP32's UART2 for DWIN screen

// Connection Pins
#define DWIN_RX 16  // ESP32 GPIO16 -> DWIN TX
#define DWIN_TX 17  // ESP32 GPIO17 -> DWIN RX

// DWIN T5UIC1 Protocol (Ender 3 V2)
const uint8_t FRAME_HEADER = 0xAA;
const uint8_t FRAME_TAIL[4] = {0xCC, 0x33, 0xC3, 0x3C};

// Commands
const uint8_t CMD_HANDSHAKE = 0x00;
const uint8_t CMD_CLEAR_SCREEN = 0x01;
const uint8_t CMD_SET_POINT = 0x02;
const uint8_t CMD_DRAW_LINE = 0x03;
const uint8_t CMD_DRAW_RECT = 0x05;
const uint8_t CMD_DRAW_BITMAP = 0x08;
const uint8_t CMD_MOVE_AREA = 0x09;
const uint8_t CMD_DRAW_STRING = 0x11;
const uint8_t CMD_DECOMPRESS_JPEG = 0x25;
const uint8_t CMD_VIRT_COPY_PASTE = 0x27;
const uint8_t CMD_BACKLIGHT = 0x30;
const uint8_t CMD_SET_DIRECTION = 0x34;
const uint8_t CMD_UPDATE_LCD = 0x3D;

// Font Sizes (from 0x11 command)
const uint8_t FONT_6x12 = 0x00;
const uint8_t FONT_8x16 = 0x01;
const uint8_t FONT_10x20 = 0x02;
const uint8_t FONT_12x24 = 0x03;
const uint8_t FONT_14x28 = 0x04;
const uint8_t FONT_16x32 = 0x05;
const uint8_t FONT_20x40 = 0x06;
const uint8_t FONT_24x48 = 0x07;
const uint8_t FONT_28x56 = 0x08;
const uint8_t FONT_32x64 = 0x09;

// Screen Dimensions (480x272 rotated 90°)
const uint16_t DWIN_WIDTH = 272;
const uint16_t DWIN_HEIGHT = 480;

// Tiling Configuration
const uint16_t TILE_WIDTH = 136;   // Half screen width for efficient transfer
const uint16_t TILE_HEIGHT = 240;  // Half screen height
const uint8_t TILES_X = 2;         // 2 tiles horizontally
const uint8_t TILES_Y = 2;         // 2 tiles vertically

// LVGL Configuration
static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf1[TILE_WIDTH * TILE_HEIGHT / 10]; // Buffer for LVGL (partial rendering)
static lv_disp_drv_t disp_drv;

// Buffer to build DWIN commands
uint8_t sendBuf[256];
uint8_t bufIndex = 0;

// Colors (RGB565)
const uint16_t COLOR_WHITE = 0xFFFF;
const uint16_t COLOR_BLACK = 0x0000;
const uint16_t COLOR_RED = 0xF800;
const uint16_t COLOR_GREEN = 0x07E0;
const uint16_t COLOR_BLUE = 0x001F;
const uint16_t COLOR_YELLOW = 0xFFE0;
const uint16_t COLOR_CYAN = 0x07FF;

// Virtual display area management
uint8_t currentVRAM = 1; // Toggle between VRAM areas for double buffering

// ============= DWIN Protocol Functions =============

void startFrame() {
  bufIndex = 0;
  sendBuf[bufIndex++] = FRAME_HEADER;
}

void addByte(uint8_t value) {
  sendBuf[bufIndex++] = value;
}

void addWord(uint16_t value) {
  sendBuf[bufIndex++] = (value >> 8) & 0xFF;  // High byte
  sendBuf[bufIndex++] = value & 0xFF;         // Low byte
}

void sendFrame() {
  DWINSerial.write(sendBuf, bufIndex);
  DWINSerial.write(FRAME_TAIL, 4);
  delay(1); // Small delay between commands
}

void addString(const char* str) {
  while (*str) {
    sendBuf[bufIndex++] = *str++;
  }
}


// Handshake with the screen
bool handshake() {
  Serial.println("Sending handshake...");
  
  startFrame();
  addByte(CMD_HANDSHAKE);
  sendFrame();
  
  delay(100);
  
  uint8_t response[26];
  int recNum = 0;
  unsigned long timeout = millis();
  
  while (millis() - timeout < 500 && recNum < 26) {
    if (DWINSerial.available()) {
      response[recNum] = DWINSerial.read();
      if (response[0] != 0xAA && recNum > 0) {
        recNum = 0;
        continue;
      }
      recNum++;
      delay(10);
    }
  }
  
  bool success = (recNum >= 4 && 
                  response[0] == 0xAA && 
                  response[1] == 0x00 && 
                  response[2] == 'O' && 
                  response[3] == 'K');
  
  if (success) {
    Serial.print("Handshake successful: ");
    for (int i = 0; i < min(recNum, 10); i++) {
      Serial.printf("%02X ", response[i]);
    }
    Serial.println();
  }
  
  return success;
}

// Clear screen
void clearScreen(uint16_t color) {
  startFrame();
  addByte(CMD_CLEAR_SCREEN);
  addWord(color);
  sendFrame();
}

// Set screen orientation (0=0°, 1=90°, 2=180°, 3=270°)
void setScreenOrientation(uint8_t dir) {
  startFrame();
  addByte(CMD_SET_DIRECTION);
  addByte(0x5A);
  addByte(0xA5);
  addByte(dir);
  sendFrame();
}

/**
 * @brief Copy and paste area from virtual display to current screen using CMD 0x27
 * @param vram_id Virtual display area (0 or 1)
 * @param xs Source upper left X coordinate in VRAM
 * @param ys Source upper left Y coordinate in VRAM
 * @param xe Source lower right X coordinate in VRAM
 * @param ye Source lower right Y coordinate in VRAM
 * @param x Destination upper left X coordinate on screen
 * @param y Destination upper left Y coordinate on screen
 */
void copyPasteVirtualDisplay(uint8_t vram_id, uint16_t xs, uint16_t ys, 
                             uint16_t xe, uint16_t ye, uint16_t x, uint16_t y) {
  // Mode byte configuration:
  // Bit 7: Background display (1=display, 0=filter)
  // Bit 6: Background restore (valid when bit 7=0)
  // Bit 5: Filter strength (valid when bit 7=0)
  // Bit 0: VRAM selection (0=#0, 1=#1)
  uint8_t mode = (vram_id & 0x01); // Use simple mode - display background
  
  startFrame();
  addByte(CMD_VIRT_COPY_PASTE);
  addByte(mode);
  addWord(xs);
  addWord(ys);
  addWord(xe);
  addWord(ye);
  addWord(x);
  addWord(y);
  sendFrame();
}

/**
 * @brief Write bitmap data directly to virtual display area
 * This function uses CMD 0x08 to write bitmap data to VRAM
 * @param vram_id Target virtual display area (0 or 1)
 * @param x Upper left X coordinate
 * @param y Upper left Y coordinate
 * @param width Width of bitmap
 * @param height Height of bitmap
 * @param data Pointer to RGB565 bitmap data
 */
void writeBitmapToVRAM(uint8_t vram_id, uint16_t x, uint16_t y, 
                       uint16_t width, uint16_t height, const uint16_t* data) {
  // Note: CMD 0x08 writes to current display. To target VRAM, we would need
  // to switch display context first or use a different approach.
  // For this implementation, we'll write directly and use copyPaste afterwards
  
  startFrame();
  addByte(CMD_DRAW_BITMAP);
  addByte(0x00); // Mode: 2-color bitmap (for simplicity)
  addWord(x);
  addWord(y);
  addWord(x + width - 1);
  addWord(y + height - 1);
  
  // Send pixel data (simplified - actual implementation may need chunking)
  for (uint32_t i = 0; i < width * height && bufIndex < 240; i++) {
    addWord(data[i]);
  }
  
  sendFrame();
}



// Draw string
// widthAdjust: true=ajustar ancho automáticamente
// bShow: true=mostrar color de fondo
// size: tamaño de fuente (usar constantes FONT_*)
// color: color del texto (RGB565)
// bColor: color de fondo (RGB565)
// x, y: coordenadas superior izquierda
// text: texto a mostrar
void drawString(bool widthAdjust, bool bShow, uint8_t size, 
                uint16_t color, uint16_t bColor, 
                uint16_t x, uint16_t y, const char* text) {
  startFrame();
  addByte(CMD_DRAW_STRING);
  
  // Configuration Byte:
  // Bit 7: widthAdjust (1=adjust, 0=no adjust)
  // Bit 6: bShow (1=display background, 0=no display)
  // Bit 5-4: Reserved (Write 0)
  // Bit 3-0: size (Font size)
  uint8_t config = (widthAdjust ? 0x80 : 0x00) | 
                   (bShow ? 0x40 : 0x00) | 
                   (size & 0x0F);
  addByte(config);
  
  addWord(color);
  addWord(bColor);
  addWord(x);
  addWord(y);
  addString(text);
  
  sendFrame();
  // DWIN Frame: AA 11 [Mode] [Color] [Bcolor] [X] [Y] [Strings] CC 33 C3 3C
  Serial.println("DWIN Frame: AA 11 [Mode] [Color] [Bcolor] [X] [Y] [Strings] CC 33 C3 3C");

}
// ============= LVGL Display Driver Functions =============

/**
 * @brief Tiled flush callback for LVGL
 * This function transfers LVGL framebuffer tiles to DWIN via CMD 0x27
 * Strategy: Use tiling to minimize data transfer and leverage VRAM for buffering
 */
void dwin_flush_cb(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
  uint16_t width = area->x2 - area->x1 + 1;
  uint16_t height = area->y2 - area->y1 + 1;
  
  Serial.printf("Flushing area: x=%d, y=%d, w=%d, h=%d\n", 
                area->x1, area->y1, width, height);
  
  // Determine which tile this area belongs to
  uint8_t tile_x = area->x1 / TILE_WIDTH;
  uint8_t tile_y = area->y1 / TILE_HEIGHT;
  
  // Calculate tile boundaries
  uint16_t tile_start_x = tile_x * TILE_WIDTH;
  uint16_t tile_start_y = tile_y * TILE_HEIGHT;
  
  // For small updates, we can transfer directly via bitmap command
  // For larger areas, use the tiling strategy with VRAM
  
  if (width * height < 1000) {
    // Small update: Direct transfer using bitmap command (simplified)
    // In real implementation, you'd need to properly implement bitmap transfer
    // For now, we'll use the copy-paste strategy
  }
  
  // Tiling strategy:
  // 1. Render tile content to VRAM area (alternating between VRAM 0 and 1)
  // 2. Use CMD 0x27 to copy from VRAM to display at correct position
  
  // Calculate source coordinates in VRAM (map tile to VRAM space)
  uint16_t vram_xs = area->x1 - tile_start_x;
  uint16_t vram_ys = area->y1 - tile_start_y;
  uint16_t vram_xe = vram_xs + width - 1;
  uint16_t vram_ye = vram_ys + height - 1;
  
  // Note: In a real implementation, you would first write the pixel data
  // to VRAM using a bitmap command or DMA transfer. Here we assume
  // the VRAM already contains the rendered content.
  
  // Copy from VRAM to display using CMD 0x27
  copyPasteVirtualDisplay(
    currentVRAM,    // Use current VRAM buffer
    vram_xs,        // Source X in VRAM
    vram_ys,        // Source Y in VRAM
    vram_xe,        // Source X end in VRAM
    vram_ye,        // Source Y end in VRAM
    area->x1,       // Destination X on screen
    area->y1        // Destination Y on screen
  );
  
  // Signal LVGL that flushing is complete
  lv_disp_flush_ready(disp);
}

/**
 * @brief LVGL tick increment (should be called every 1ms)
 */
void lv_tick_inc_cb() {
  lv_tick_inc(1);
}

// ============= LVGL UI Creation =============

/**
 * @brief Create sample LVGL UI
 */
void create_ui() {
  // Create a screen
  lv_obj_t *scr = lv_obj_create(NULL);
  lv_scr_load(scr);
  
  // Set background color
  lv_obj_set_style_bg_color(scr, lv_color_hex(0x003a57), 0);
  
  // Create title label
  lv_obj_t *label_title = lv_label_create(scr);
  lv_label_set_text(label_title, "DWIN + LVGL Tiled Display");
  lv_obj_set_style_text_color(label_title, lv_color_white(), 0);
  //lv_obj_set_style_text_font(label_title, &lv_font_montserrat_24, 0);
  lv_obj_align(label_title, LV_ALIGN_TOP_MID, 0, 20);
  
  // Create status label
  lv_obj_t *label_status = lv_label_create(scr);
  lv_label_set_text(label_status, "Tiling Strategy Active\nCmd 0x27 for Data Transfer");
  lv_obj_set_style_text_color(label_status, lv_color_hex(0x00ff00), 0);
  lv_obj_align(label_status, LV_ALIGN_CENTER, 0, -50);
  
  // Create a button
  lv_obj_t *btn = lv_btn_create(scr);
  lv_obj_set_size(btn, 150, 60);
  lv_obj_align(btn, LV_ALIGN_CENTER, 0, 40);
  lv_obj_set_style_bg_color(btn, lv_color_hex(0x2196F3), 0);
  
  lv_obj_t *btn_label = lv_label_create(btn);
  lv_label_set_text(btn_label, "Click Me");
  lv_obj_center(btn_label);
  
  // Create a slider
  lv_obj_t *slider = lv_slider_create(scr);
  lv_obj_set_width(slider, 200);
  lv_obj_align(slider, LV_ALIGN_BOTTOM_MID, 0, -60);
  lv_slider_set_value(slider, 50, LV_ANIM_OFF);
  
  // Create slider label
  lv_obj_t *slider_label = lv_label_create(scr);
  lv_label_set_text(slider_label, "Brightness: 50%");
  lv_obj_set_style_text_color(slider_label, lv_color_white(), 0);
  lv_obj_align_to(slider_label, slider, LV_ALIGN_OUT_TOP_MID, 0, -10);
  
  // Create tile indicators (visual representation of tiling strategy)
  for (uint8_t y = 0; y < TILES_Y; y++) {
    for (uint8_t x = 0; x < TILES_X; x++) {
      lv_obj_t *tile_indicator = lv_obj_create(scr);
      lv_obj_set_size(tile_indicator, TILE_WIDTH - 4, TILE_HEIGHT - 4);
      lv_obj_set_pos(tile_indicator, x * TILE_WIDTH + 2, y * TILE_HEIGHT + 2);
      lv_obj_set_style_bg_opa(tile_indicator, LV_OPA_TRANSP, 0);
      lv_obj_set_style_border_color(tile_indicator, lv_color_hex(0xff0000), 0);
      lv_obj_set_style_border_width(tile_indicator, 2, 0);
      lv_obj_set_style_border_opa(tile_indicator, LV_OPA_30, 0);
    }
  }
  
  Serial.println("LVGL UI created successfully");
}

// ============= Setup and Loop =============

void setup() {
  Serial.begin(115200);
  DWINSerial.begin(115200, SERIAL_8N1, DWIN_RX, DWIN_TX);
  
  delay(500);
  
  Serial.println("\n=== Initializing DWIN T5UIC1 + LVGL Tiled Display ===");
  clearScreen(COLOR_BLACK);
  drawString(true, true, FONT_6x12, COLOR_WHITE, COLOR_BLUE, 10, 10, "INIT OK");
  
  // Initialize DWIN screen
  if (handshake()) {
    Serial.println("✓ DWIN Handshake successful");
    drawString(true, true, FONT_6x12, COLOR_WHITE, COLOR_BLUE, 10, 20, "Handshake: OK");
    
    delay(100);
    
    // Set orientation (1 = 90° rotation)
    setScreenOrientation(1);
    delay(50);
    
    // Clear screen to black
    //clearScreen(COLOR_BLACK);
    delay(100);
    
    // Initialize LVGL
    lv_init();
    
    // Initialize display buffer for LVGL
    lv_disp_draw_buf_init(&draw_buf, buf1, NULL, TILE_WIDTH * TILE_HEIGHT / 10);
    
    // Initialize display driver
    lv_disp_drv_init(&disp_drv);
    disp_drv.hor_res = DWIN_WIDTH;
    disp_drv.ver_res = DWIN_HEIGHT;
    disp_drv.flush_cb = dwin_flush_cb;
    disp_drv.draw_buf = &draw_buf;
    lv_disp_drv_register(&disp_drv);
    
    Serial.println("✓ LVGL initialized");
    drawString(true, true, FONT_6x12, COLOR_WHITE, COLOR_BLUE, 10, 30, "LVGL: initialized");
    Serial.printf("   Screen: %dx%d\n", DWIN_WIDTH, DWIN_HEIGHT);
    Serial.printf("   Tiling: %dx%d tiles (%dx%d pixels each)\n", 
                  TILES_X, TILES_Y, TILE_WIDTH, TILE_HEIGHT);
    
    // Create UI
    create_ui();
    
    // Setup timer for LVGL tick (1ms)
    // Note: In production, use hardware timer
    // For this example, we'll call lv_tick_inc in loop
    
    Serial.println("✓ Setup complete");
    drawString(true, true, FONT_6x12, COLOR_WHITE, COLOR_BLUE, 10, 40, "SETUP: completed");
    
  } else {
    Serial.println("✗ DWIN Handshake failed");
    while(1) delay(1000);
  }
}

void loop() {
  // Handle LVGL tasks
  lv_timer_handler();
  
  // Increment LVGL tick (normally done in timer interrupt)
  static unsigned long last_tick = 0;
  if (millis() - last_tick >= 5) {
    lv_tick_inc(5);
    last_tick = millis();
  }
  
  delay(5); // 5ms delay for ~200Hz refresh rate
}

/**
 * TILING STRATEGY EXPLANATION:
 * 
 * 1. Screen Division:
 *    - Divide 272x480 screen into 2x2 tiles (136x240 each)
 *    - Each tile is small enough for efficient transfer via CMD 0x27
 * 
 * 2. VRAM Usage:
 *    - Use VRAM #0 and #1 alternately for double buffering
 *    - Render LVGL content to VRAM tile-by-tile
 *    - Use CMD 0x27 to copy completed tiles to display
 * 
 * 3. Update Strategy:
 *    - LVGL's dirty rectangle system determines which areas need update
 *    - Map dirty rectangles to corresponding tiles
 *    - Transfer only changed tiles using CMD 0x27
 *
 */
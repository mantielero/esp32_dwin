#include <HardwareSerial.h>

// DWIN T5UIC1 Screen Configuration
HardwareSerial DWINSerial(2); // Use ESP32's UART2 for DWIN screen

// Connection Pins
#define DWIN_RX 16  // ESP32 GPIO16 -> DWIN TX
#define DWIN_TX 17  // ESP32 GPIO17 -> DWIN RX

// DWIN T5UIC1 Protocol (Ender 3 V2)
const uint8_t FRAME_HEADER = 0xAA;
const uint8_t FRAME_TAIL[4] = {0xCC, 0x33, 0xC3, 0x3C};


// Commands
const uint8_t CMD_HANDSHAKE = 0x00;
const uint8_t CMD_CLEAR_SCREEN = 0x01;
const uint8_t CMD_SET_POINT = 0x02;         // New: Set paint
const uint8_t CMD_DRAW_LINE = 0x03;         // New: End point connection
const uint8_t CMD_DRAW_RECT = 0x05;         // New: Rectangular area display
const uint8_t CMD_DRAW_BITMAP = 0x08;       // New: Two-color bitmap filling
const uint8_t CMD_MOVE_AREA = 0x09;         // New: Screen area move
const uint8_t CMD_DRAW_STRING = 0x11;
const uint8_t CMD_VIRT_COPY_PASTE = 0x27;   // New: Copy and paste from virtual display area
const uint8_t CMD_BACKLIGHT = 0x30;
const uint8_t CMD_SET_DIRECTION = 0x34;
const uint8_t CMD_UPDATE_LCD = 0x3D;        // Note: This command is not in the provided manual but is often used in DWIN.


// Font Sizes (from 0x11 command)
const uint8_t FONT_6x12 = 0x00;
const uint8_t FONT_8x16 = 0x01;
const uint8_t FONT_10x20 = 0x02;
const uint8_t FONT_12x24 = 0x03;
const uint8_t FONT_14x28 = 0x04;
const uint8_t FONT_16x32 = 0x05;
const uint8_t FONT_20x40 = 0x06;
const uint8_t FONT_24x48 = 0x07;
const uint8_t FONT_28x56 = 0x08;
const uint8_t FONT_32x64 = 0x09;

// Colors (RGB565)
const uint16_t COLOR_WHITE = 0xFFFF;
const uint16_t COLOR_BLACK = 0x0000;
const uint16_t COLOR_RED = 0xF800;
const uint16_t COLOR_GREEN = 0x07E0;
const uint16_t COLOR_BLUE = 0x001F;
const uint16_t COLOR_YELLOW = 0xFFE0;
const uint16_t COLOR_MAGENTA = 0xF81F;
const uint16_t COLOR_CYAN = 0x07FF;
const uint16_t COLOR_BG_BLACK = 0x0841;
const uint16_t COLOR_BG_BLUE = 0x1125;

// Screen Dimensions (Note: Dimensions seem swapped in your original code based on a 480x272 screen rotated 90 deg)
const uint16_t DWIN_WIDTH = 272;
const uint16_t DWIN_HEIGHT = 480;

// Buffer to build commands
uint8_t sendBuf[256];
uint8_t bufIndex = 0;

// ============= Funciones del protocolo DWIN T5UIC1 (Implementation) =============

void startFrame() {
  bufIndex = 0;
  sendBuf[bufIndex++] = FRAME_HEADER;
}

void addByte(uint8_t value) {
  sendBuf[bufIndex++] = value;
}

void addWord(uint16_t value) {
  sendBuf[bufIndex++] = (value >> 8) & 0xFF;  // High byte
  sendBuf[bufIndex++] = value & 0xFF;         // Low byte
}

void addString(const char* str) {
  while (*str) {
    sendBuf[bufIndex++] = *str++;
  }
}

void sendFrame() {
  // Send buffer
  DWINSerial.write(sendBuf, bufIndex);
  // Send tail
  DWINSerial.write(FRAME_TAIL, 4);
  
  delay(1); // Small delay between commands
}

// Handshake with the scree
bool handshake() {
  Serial.println("Sending handshake...");
  
  startFrame();
  addByte(CMD_HANDSHAKE);
  sendFrame();
  
  delay(100);
  
  // Wait for response: AA 00 4F 4B (AA 00 'O' 'K')
  uint8_t response[26];
  int recNum = 0;
  unsigned long timeout = millis();
  
  while (millis() - timeout < 500 && recNum < 26) {
    if (DWINSerial.available()) {
      response[recNum] = DWINSerial.read();
      
      // Check if the first byte is correct
      if (response[0] != 0xAA && recNum > 0) {
        recNum = 0;
        continue;
      }
      
      recNum++;
      delay(10);
    }
  }
  
  // Check response: AA 00 'O' 'K'
  bool success = (recNum >= 4 && 
                  response[0] == 0xAA && 
                  response[1] == 0x00 && 
                  response[2] == 'O' && 
                  response[3] == 'K');
  
  if (success) {
    Serial.printf("Handshake response: ");
    for (int i = 0; i < min(recNum, 10); i++) {
      Serial.printf("%02X ", response[i]);
    }
    Serial.println();
  }
  
  return success;
}


// ================ Drawing Functions ================
// Clear screen
void clearScreen(uint16_t color) {
  startFrame();
  addByte(CMD_CLEAR_SCREEN);
  addWord(color);
  sendFrame();
  
  // DWIN Frame: AA 01 [Color H] [Color L] CC 33 C3 3C
  Serial.println("DWIN Frame: AA 01 [Color] CC 33 C3 3C");
}


// Set screen orientation
// dir: 0=0°, 1=90°, 2=180°, 3=270°
void setScreenOrientation(uint8_t dir) {
  startFrame();
  addByte(CMD_SET_DIRECTION);
  addByte(0x5A);
  addByte(0xA5);
  addByte(dir);
  sendFrame();

  // DWIN Frame: AA 34 5A A5 [Dir] CC 33 C3 3C
  Serial.println("DWIN Frame: AA 34 5A A5 [Dir] CC 33 C3 3C");
}


// Update LCD (refresh display memory)
void updateLCD() {
  // Note: This is an unlisted command (0x3D) often used for full screen refresh.
  // The provided manual does not list this command.
  startFrame();
  addByte(CMD_UPDATE_LCD); 
  sendFrame();
}


// Draw string
void drawString(bool widthAdjust, bool bShow, uint8_t size, 
                uint16_t color, uint16_t bColor, 
                uint16_t x, uint16_t y, const char* text) {
  startFrame();
  addByte(CMD_DRAW_STRING);
  
  // Configuration Byte:
  // Bit 7: widthAdjust (1=adjust, 0=no adjust)
  // Bit 6: bShow (1=display background, 0=no display)
  // Bit 5-4: Reserved (Write 0)
  // Bit 3-0: size (Font size)
  uint8_t config = (widthAdjust ? 0x80 : 0x00) | 
                   (bShow ? 0x40 : 0x00) | 
                   (size & 0x0F);
  addByte(config);
  
  addWord(color);
  addWord(bColor);
  addWord(x);
  addWord(y);
  addString(text);
  
  sendFrame();
  // DWIN Frame: AA 11 [Mode] [Color] [Bcolor] [X] [Y] [Strings] CC 33 C3 3C
  Serial.println("DWIN Frame: AA 11 [Mode] [Color] [Bcolor] [X] [Y] [Strings] CC 33 C3 3C");

}


// Draw rectangle (CMD 0x05)
void drawRectangle(uint8_t mode, uint16_t color, 
                   uint16_t xs, uint16_t ys, uint16_t xe, uint16_t ye) {
  // DWIN Frame: AA 05 [Mode] [Color] [Xs] [Ys] [Xe] [Ye] CC 33 C3 3C
  startFrame();
  addByte(CMD_DRAW_RECT);
  addByte(mode);
  addWord(color);
  addWord(xs); // Upper left X
  addWord(ys); // Upper left Y
  addWord(xe); // Lower right X
  addWord(ye); // Lower right Y

  sendFrame();
  Serial.println("DWIN Frame: AA 05 [Mode] [Color] [Xs] [Ys] [Xe] [Ye] CC 33 C3 3C");
}

// Decompress JPEG picture to virtual display area #1 (CMD 0x25)
void decompressJPEGToVRAM1(uint8_t jpeg_id) {
  // DWIN Frame: AA 25 01 [JPEG_ID] CC 33 C3 3C
  startFrame();
  addByte(0x25);
  addByte(0x01);    // Target VRAM: 1# virtual display area
  addByte(jpeg_id); // JPEG ID
  sendFrame();
  Serial.println("DWIN Frame: AA 25 01 [JPEG_ID] CC 33 C3 3C (Decompress JPEG to VRAM 1)");
}


// ==================== CMD 0x27 Implementation ====================

/**
 * @brief Copies and pastes an area from a virtual display area (#0 or #1) to the current display.
 * * DWIN Frame Pattern: AA 27 [Mode] [Xs] [Ys] [Xe] [Ye] [X] [Y] CC 33 C3 3C
 * * @param vram_id Virtual display area to use (0 or 1).
 * @param background_display Setting for icon background display (1=display, 0=filter/not display).
 * @param background_restore Setting for background restore (1=restore from 0# VRAM, 0=no restore). Only valid when background_display=0.
 * @param filter_strength Background filtering strength selection (0=normal, 1=enhanced). Only valid when background_display=0.
 * @param xs Upper left X coordinate of the selected area in the virtual display area.
 * @param ys Upper left Y coordinate of the selected area in the virtual display area.
 * @param xe Lower right X coordinate of the selected area in the virtual display area.
 * @param ye Lower right Y coordinate of the selected area in the virtual display area.
 * @param x Upper left X coordinate for pasting on the current display area.
 * @param y Upper left Y coordinate for pasting on the current display area.
 */
void copyPasteVirtualDisplay(uint8_t vram_id, bool background_display, bool background_restore, 
                             bool filter_strength, uint16_t xs, uint16_t ys, uint16_t xe, uint16_t ye, 
                             uint16_t x, uint16_t y) {
  
  // Build the Mode byte (8 bits)
  // .7: Background display setting (1=display, 0=filter/not display)
  // .6: Background restore (1=restore from 0# VRAM, 0=no restore). Valid only if .7=0.
  // .5: Background filtering strength (1=enhanced, 0=normal). Valid only if .7=0.
  // .4-.1: Reserved (Write 0)
  // .0: Virtual display area selection (0=0# VRAM, 1=1# VRAM)
  uint8_t mode = (background_display ? 0x80 : 0x00) |
                 ((!background_display && background_restore) ? 0x40 : 0x00) |
                 ((!background_display && filter_strength) ? 0x20 : 0x00) |
                 (vram_id & 0x01); // Mask only the lowest bit for VRAM selection
  
  startFrame();
  addByte(CMD_VIRT_COPY_PASTE);
  addByte(mode);
  
  // Source area in Virtual VRAM (Xs, Ys, Xe, Ye)
  addWord(xs); 
  addWord(ys);
  addWord(xe);
  addWord(ye);
  
  // Destination position on current screen (X, Y)
  addWord(x); 
  addWord(y);
  
  sendFrame();
  
  // DWIN Frame: AA 27 [Mode] [Xs] [Ys] [Xe] [Ye] [X] [Y] CC 33 C3 3C
  Serial.println("DWIN Frame: AA 27 [Mode] [Xs] [Ys] [Xe] [Ye] [X] [Y] CC 33 C3 3C");
}

// =================================================================

void setup() {
  Serial.begin(115200);
  DWINSerial.begin(115200, SERIAL_8N1, DWIN_RX, DWIN_TX);
  
  delay(500);
  
  Serial.println("\n=== Initializing DWIN T5UIC1 screen (Ender 3 V2) ===");
  
  // Handshake
  if (handshake()) {
    Serial.println("✓ Handshake successful");
    
    delay(100);
    
    // Set Orientation (1 = 90° rotation)
    setScreenOrientation(1);
    delay(50);
    
    // Clear screen to black
    clearScreen(COLOR_BLACK);
    delay(100);
    
    // === EXAMPLE USAGE FOR CMD 0x27 ===

    // Step 1: Decompress a JPEG picture into the 1# virtual display area (VRAM 1).
    // This step is necessary to have content to copy from VRAM 1.
    // NOTE: You must have a JPEG file named "01*.JPG" on the SD card (ID 0x01).
    // Let's assume a picture with ID 0x01 (e.g., 1_my_image.JPG) is present.
    // This command takes about 240mS, so wait a bit.
    drawString(true, true, FONT_16x32, COLOR_WHITE, COLOR_BLACK, 10, 10, "Decompressing JPEG 01 to VRAM 1...");
    updateLCD();
    decompressJPEGToVRAM1(0x01); 
    delay(300); 
    clearScreen(COLOR_BLACK);
    
    // Step 2: Copy a section of the virtual screen and paste it to the current screen.
    // We will copy the top-left quadrant (0, 0) to (136, 240) of VRAM 1 
    // and paste it at a shifted location (10, 10) on the main screen.
    
    drawString(true, true, FONT_16x32, COLOR_GREEN, COLOR_BLACK, 10, 10, "Pasting VRAM 1 section (CMD 0x27)");
    updateLCD();

    // VRAM 1 (vram_id=1), Background display OFF (background_display=0), No restore (background_restore=0), Normal filter (filter_strength=0).
    copyPasteVirtualDisplay(
      1,     // vram_id: Use 1# virtual display area
      false, // background_display: Filter background (0-Background filtering is not displayed)
      false, // background_restore: Do not restore background
      false, // filter_strength: Normal filter strength
      0,     // xs: Source X start (top-left)
      0,     // ys: Source Y start
      DWIN_WIDTH/2 - 1,   // xe: Source X end (e.g., 135 for 272 width)
      DWIN_HEIGHT/2 - 1,  // ye: Source Y end (e.g., 239 for 480 height)
      50,    // x: Destination X on current screen
      50     // y: Destination Y on current screen
    );
    
    delay(50); // Give time for the copy/paste operation (processing time is 0.2uS per pixel)

    // Optional: Draw a border around the pasted area
    drawRectangle(0x00, COLOR_RED, 
                  50, 50, 
                  50 + DWIN_WIDTH/2 - 1, 
                  50 + DWIN_HEIGHT/2 - 1);
                  
    updateLCD();
    Serial.println("✓ Virtual Copy/Paste example executed.");
    
  } else {
    Serial.println("✗ Handshake Error");
  }
}

void loop() {
  // Main loop logic here
}